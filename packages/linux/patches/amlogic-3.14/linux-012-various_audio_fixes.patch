From f572683177ee5b0ccd88e3413ef904f407dd0a4e Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Mon, 7 Nov 2016 19:38:06 +0100
Subject: [PATCH 01/11] sound/soc/aml/m8: work-in-progress

---
 sound/soc/aml/m8/aml_audio_hw.c    | 48 ++++++++++-----------------
 sound/soc/aml/m8/aml_i2s.c         | 66 ++++++++++++++++++++++----------------
 sound/soc/aml/m8/aml_i2s_dai.c     |  3 +-
 sound/soc/aml/m8/aml_spdif_codec.c |  2 +-
 sound/soc/aml/m8/aml_spdif_dai.c   |  5 +++
 5 files changed, 63 insertions(+), 61 deletions(-)

diff --git a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
index 70e3f70cd20f..5c21fd527e13 100644
--- a/sound/soc/aml/m8/aml_audio_hw.c
+++ b/sound/soc/aml/m8/aml_audio_hw.c
@@ -148,8 +148,8 @@ int audio_clock_config_table[][13][2] = {
 void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 {
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffff00);
-	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffff00);
+	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr);
+	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr);
 #else
 	aml_write_cbus(AIU_MEM_I2S_START_PTR, addr & 0xffffffc0);
 	aml_write_cbus(AIU_MEM_I2S_RD_PTR, addr & 0xffffffc0);
@@ -158,8 +158,7 @@ void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 	if (channel == 8) {
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 1 << 6);
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-		aml_write_cbus(AIU_MEM_I2S_END_PTR,
-			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
+		aml_write_cbus(AIU_MEM_I2S_END_PTR, addr + size - 256);
 #else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 256);
@@ -167,8 +166,7 @@ void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 	} else {
 		aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 1 << 6, 0 << 6);
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-		aml_write_cbus(AIU_MEM_I2S_END_PTR,
-			(addr & 0xffffff00) + (size & 0xffffff00) - 256);
+		aml_write_cbus(AIU_MEM_I2S_END_PTR, addr + size - 256);
 #else
 		aml_write_cbus(AIU_MEM_I2S_END_PTR,
 			       (addr & 0xffffffc0) + (size & 0xffffffc0) - 64);
@@ -212,29 +210,23 @@ void audio_set_aiubuf(u32 addr, u32 size, unsigned int channel)
 	aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1, 1);
 	aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1, 0);
 
-	aml_write_cbus(AIU_MEM_I2S_BUF_CNTL, 1 | (0 << 1));
-	aml_write_cbus(AIU_MEM_I2S_BUF_CNTL, 0 | (0 << 1));
-
 	audio_out_buf_ready = 1;
 }
 
 void audio_set_958outbuf(u32 addr, u32 size, int flag)
 {
 	if (ENABLE_IEC958) {
-		aml_write_cbus(AIU_MEM_IEC958_START_PTR, addr & 0xffffffc0);
+		aml_write_cbus(AIU_MEM_IEC958_START_PTR, addr);
 		if (aml_read_cbus(AIU_MEM_IEC958_START_PTR) ==
 		    aml_read_cbus(AIU_MEM_I2S_START_PTR)) {
 			aml_write_cbus(AIU_MEM_IEC958_RD_PTR,
 				       aml_read_cbus(AIU_MEM_I2S_RD_PTR));
 		} else
-			aml_write_cbus(AIU_MEM_IEC958_RD_PTR,
-				       addr & 0xffffffc0);
+			aml_write_cbus(AIU_MEM_IEC958_RD_PTR, addr);
 		if (flag == 0) {
 			/* this is for 16bit 2 channel */
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
-				(addr & 0xffffffc0) +
-				(size & 0xffffffc0) - 8);
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR, addr + size - 8);
 #else
 			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
 				       (addr & 0xffffffc0) +
@@ -243,9 +235,7 @@ void audio_set_958outbuf(u32 addr, u32 size, int flag)
 		} else {
 			/* this is for RAW mode */
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
-						(addr & 0xffffffc0) +
-						(size & 0xffffffc0) - 8);
+			aml_write_cbus(AIU_MEM_IEC958_END_PTR, addr + size - 8);
 #else
 			aml_write_cbus(AIU_MEM_IEC958_END_PTR,
 				       (addr & 0xffffffc0) +
@@ -259,9 +249,6 @@ void audio_set_958outbuf(u32 addr, u32 size, int flag)
 #endif
 		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 1);
 		aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1, 0);
-
-		aml_write_cbus(AIU_MEM_IEC958_BUF_CNTL, 1 | (0 << 1));
-		aml_write_cbus(AIU_MEM_IEC958_BUF_CNTL, 0 | (0 << 1));
 	}
 }
 
@@ -539,16 +526,15 @@ void audio_set_i2s_mode(u32 mode, unsigned int channel)
 
 			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
 						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
 			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
 						7 << 6);
 		} else if (mode == AIU_I2S_MODE_PCM24) {
-			/* todo: to verify it */
 			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
 
 			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
 						1 << 9);
-			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
-						7 << 6);
 			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
 						1 << 5);
 
@@ -558,8 +544,6 @@ void audio_set_i2s_mode(u32 mode, unsigned int channel)
 
 			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
 						2 << 3);
-
-			aml_cbus_update_bits(AIU_CLK_CTRL_MORE, 0x1f, 0x5);
 		}
 	} else if (2 == channel) {
 		aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 0, 0);
@@ -573,15 +557,17 @@ void audio_set_i2s_mode(u32 mode, unsigned int channel)
 		} else if (mode == AIU_I2S_MODE_PCM24) {
 			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
 
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
+						1 << 9);
 			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
 						1 << 5);
-			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 2 << 3,
-						2 << 3);
 		} else if (mode == AIU_I2S_MODE_PCM32) {
 			aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 1 << 6, 0);
 
 			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 9,
 						1 << 9);
+			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 1 << 5,
+						1 << 5);
 			aml_cbus_update_bits(AIU_I2S_SOURCE_DESC, 7 << 6,
 						7 << 6);
 		}
@@ -918,7 +904,7 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 		audio_hw_set_958_pcm24(set);
 		if (ENABLE_IEC958) {
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-			aml_write_cbus(AIU_958_MISC, 0x3480);
+			aml_write_cbus(AIU_958_MISC, 0x3780);
 			/* pcm */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
 						1 << 8);
@@ -938,7 +924,7 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 		audio_hw_set_958_pcm24(set);
 		if (ENABLE_IEC958) {
 #ifdef CONFIG_SND_AML_SPLIT_MODE
-			aml_write_cbus(AIU_958_MISC, 0x3480);
+			aml_write_cbus(AIU_958_MISC, 0x3080);
 			/* pcm */
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
 						1 << 8);
@@ -958,7 +944,7 @@ void audio_set_958_mode(unsigned mode, struct _aiu_958_raw_setting_t *set)
 	} else if (mode == AIU_958_MODE_PCM16) {
 		audio_hw_set_958_pcm24(set);
 		if (ENABLE_IEC958) {
-			aml_write_cbus(AIU_958_MISC, 0x2042);
+			aml_write_cbus(AIU_958_MISC, 0x3042);
 			/* pcm */
 #ifdef CONFIG_SND_AML_SPLIT_MODE
 			aml_cbus_update_bits(AIU_MEM_IEC958_CONTROL, 1 << 8,
diff --git a/sound/soc/aml/m8/aml_i2s.c b/sound/soc/aml/m8/aml_i2s.c
index a2bf64e66ac0..b7ff908c8b4d 100644
--- a/sound/soc/aml/m8/aml_i2s.c
+++ b/sound/soc/aml/m8/aml_i2s.c
@@ -90,14 +90,14 @@ static const struct snd_pcm_hardware aml_i2s_hardware = {
 	    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
 	    SNDRV_PCM_FMTBIT_S32_LE,
 
-	.period_bytes_min = 64,
-	.period_bytes_max = 32 * 1024 * 2,
-	.periods_min = 2,
-	.periods_max = 1024,
-	.buffer_bytes_max = 128 * 1024 * 2 * 2,
+	.period_bytes_min = 256,
+	.period_bytes_max = 32 * 1024,
+	.periods_min = 4,
+	.periods_max = 64,
+	.buffer_bytes_max = 32 * 1024 * 64,
 
 	.rate_min = 8000,
-	.rate_max = 48000,
+	.rate_max = 192000,
 	.channels_min = 2,
 	.channels_max = 8,
 #ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
@@ -127,17 +127,6 @@ static const struct snd_pcm_hardware aml_i2s_capture = {
 	.fifo_size = 0,
 };
 
-static unsigned int period_sizes[] = {
-	64, 128, 256, 512, 1024, 2048, 4096, 8192,
-	16384, 32768, 65536, 65536 * 2, 65536 * 4
-};
-
-static struct snd_pcm_hw_constraint_list hw_constraints_period_sizes = {
-	.count = ARRAY_SIZE(period_sizes),
-	.list = period_sizes,
-	.mask = 0
-};
-
 /*--------------------------------------------------------------------------*/
 /*--------------------------------------------------------------------------*\
  * Helper functions
@@ -273,6 +262,7 @@ static int aml_i2s_hw_params(struct snd_pcm_substream *substream,
 
 		s->last_ptr = 0;
 	}
+	s->size = 0;
 
 	return 0;
 }
@@ -298,6 +288,21 @@ static int aml_i2s_prepare(struct snd_pcm_substream *substream)
 	if (s && s->device_type == AML_AUDIO_I2SOUT)
 		aml_i2s_playback_channel = runtime->channels;
 	tmp_buf->cached_len = 0;
+
+	/*
+	* Both capture and playback need to reset the last ptr
+	* to the start address, playback and capture use
+	* different address calculate, so we reset the different
+	* start address to the last ptr
+	*/
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* s->last_ptr must initialized as dma buffer's start addr */
+		s->last_ptr = runtime->dma_addr;
+	} else {
+		s->last_ptr = 0;
+	}
+	s->size = 0;
+
 	return 0;
 }
 
@@ -519,24 +524,27 @@ static int aml_i2s_open(struct snd_pcm_substream *substream)
 		snd_soc_set_runtime_hwparams(substream, &aml_i2s_capture);
 	}
 
-	/* ensure that peroid size is a multiple of 32bytes */
-	ret =
-	    snd_pcm_hw_constraint_list(runtime, 0,
-				       SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
-				       &hw_constraints_period_sizes);
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0) {
+		dev_err(substream->pcm->card->dev, "set periods constraint error\n");
+		goto out;
+	}
+
+	/* ensure that peroid bytes is a multiple of 256 bytes */
+	ret = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 256);
 	if (ret < 0) {
-		dev_err(substream->pcm->card->dev,
-			"set period bytes constraint error\n");
+		dev_err(substream->pcm->card->dev, "set period bytes constraint error\n");
 		goto out;
 	}
 
-	/* ensure that buffer size is a multiple of period size */
-	ret = snd_pcm_hw_constraint_integer(runtime,
-					    SNDRV_PCM_HW_PARAM_PERIODS);
+	/* ensure that buffer bytes is a multiple of 512 bytes */
+	ret = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 512);
 	if (ret < 0) {
-		dev_err(substream->pcm->card->dev, "set period error\n");
+		dev_err(substream->pcm->card->dev, "set buffer bytes constraint error\n");
 		goto out;
 	}
+
 	if (!prtd) {
 		prtd = kzalloc(sizeof(struct aml_runtime_data), GFP_KERNEL);
 		if (prtd == NULL) {
@@ -859,8 +867,10 @@ static struct snd_pcm_ops aml_i2s_ops = {
 #ifdef CONFIG_SND_AML_SPLIT_MODE_MMAP
 	.mmap = aml_pcm_mmap,
 #else
+#ifndef CONFIG_SND_AML_SPLIT_MODE
 	.copy = aml_i2s_copy,
 #endif
+#endif
 	.silence = aml_i2s_silence,
 };
 
diff --git a/sound/soc/aml/m8/aml_i2s_dai.c b/sound/soc/aml/m8/aml_i2s_dai.c
index 2e6a3a2be536..89a535a321f1 100644
--- a/sound/soc/aml/m8/aml_i2s_dai.c
+++ b/sound/soc/aml/m8/aml_i2s_dai.c
@@ -121,6 +121,7 @@ static void aml_hw_i2s_init(struct snd_pcm_runtime *runtime)
 #else
 	audio_set_i2s_mode(i2s_mode);
 #endif
+	memset(runtime->dma_area, 0, runtime->dma_bytes);
 	audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes,
 			 runtime->channels);
 }
@@ -539,7 +540,7 @@ static int aml_dai_i2s_resume(struct snd_soc_dai *dai)
 	return 0;
 }
 
-#define AML_DAI_I2S_RATES		(SNDRV_PCM_RATE_8000_192000)
+#define AML_DAI_I2S_RATES		(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)
 #define AML_DAI_I2S_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
 		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
diff --git a/sound/soc/aml/m8/aml_spdif_codec.c b/sound/soc/aml/m8/aml_spdif_codec.c
index ac76ef6dfb7f..92b0e636533c 100644
--- a/sound/soc/aml/m8/aml_spdif_codec.c
+++ b/sound/soc/aml/m8/aml_spdif_codec.c
@@ -26,7 +26,7 @@
 
 #define DRV_NAME "spdif-dit"
 
-#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
+#define STUB_RATES	(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)
 #define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
 	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
diff --git a/sound/soc/aml/m8/aml_spdif_dai.c b/sound/soc/aml/m8/aml_spdif_dai.c
index 405d2233781f..63ca0274eecc 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.c
+++ b/sound/soc/aml/m8/aml_spdif_dai.c
@@ -216,6 +216,7 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 #else
 		audio_set_i2s_mode(i2s_mode);
 #endif
+		memset(runtime->dma_area, 0, runtime->dma_bytes);
 		audio_set_aiubuf(runtime->dma_addr, runtime->dma_bytes, (runtime->format == SNDRV_PCM_FORMAT_S16) ? 2 : runtime->channels);
 	}
 
@@ -240,6 +241,10 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 		IEC958_mode_codec = 4; /* EAC3 */
 		pr_info("set 4x audio clk for 958\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
+	} else if (samesrc && runtime->channels == 8 && runtime->format == SNDRV_PCM_FORMAT_S16) {
+		IEC958_mode_codec = 0;
+		pr_info("share the same clock\n");
+		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 2 << 4);
 	} else if (samesrc) {
 		IEC958_mode_codec = 0;
 		pr_info("share the same clock\n");
-- 
2.11.0


From 951819bd59da90a8176cbd34ba7f7ffe05e8f134 Mon Sep 17 00:00:00 2001
From: kszaq <kszaquitto@gmail.com>
Date: Thu, 23 Feb 2017 23:14:00 +0100
Subject: [PATCH 02/11] sound/soc: add es8323 codec

---
 sound/soc/aml/m8/Kconfig  |   1 +
 sound/soc/codecs/Kconfig  |   4 +
 sound/soc/codecs/Makefile |   2 +
 sound/soc/codecs/es8323.c | 982 ++++++++++++++++++++++++++++++++++++++++++++++
 sound/soc/codecs/es8323.h | 156 ++++++++
 5 files changed, 1145 insertions(+)
 create mode 100644 sound/soc/codecs/es8323.c
 create mode 100644 sound/soc/codecs/es8323.h

diff --git a/sound/soc/aml/m8/Kconfig b/sound/soc/aml/m8/Kconfig
index 045f91e19029..6d67a817c8fa 100644
--- a/sound/soc/aml/m8/Kconfig
+++ b/sound/soc/aml/m8/Kconfig
@@ -10,6 +10,7 @@ menuconfig SND_AML_M8
 	select SND_SOC_TAS5731
 	select SND_SOC_AMLT9015
 	select SND_SOC_AMLT9015S
+	select SND_SOC_ES8323
 
 if SND_AML_M8
 
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 4e47e466a54a..5a34ea553ae5 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -138,6 +138,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_TAS5717 if I2C
 	select SND_SOC_TAS5731 if I2C
 	select SND_SOC_AMLPMU4 if I2C
+	select SND_SOC_ES8323 if I2C
         help
           Normally ASoC codec drivers are only built if a machine driver which
           uses them is also built since they are only usable with a machine
@@ -578,6 +579,9 @@ config SND_SOC_TAS5731
 config SND_SOC_AMLPMU4
 	tristate
 
+config SND_SOC_ES8323
+	tristate
+
 config SND_SOC_PCM2BT
 	tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index a938765fc71d..711ef1151aa1 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -129,6 +129,7 @@ snd-soc-pcm2bt-objs  := pcm2bt.o
 snd-soc-amlpmu4-objs := aml_pmu4_codec.o
 snd-soc-aml_t9015-objs := aml_codec_t9015.o
 snd-soc-aml_t9015S-objs := aml_codec_t9015S.o
+snd-soc-es8323-objs := es8323.o
 
 # Amp
 snd-soc-max9877-objs := max9877.o
@@ -267,6 +268,7 @@ obj-$(CONFIG_SND_SOC_PCM2BT)	+= snd-soc-pcm2bt.o
 obj-$(CONFIG_SND_SOC_AMLPMU4)	+= snd-soc-amlpmu4.o
 obj-$(CONFIG_SND_SOC_AMLT9015)	+= snd-soc-aml_t9015.o
 obj-$(CONFIG_SND_SOC_AMLT9015S)	+= snd-soc-aml_t9015S.o
+obj-$(CONFIG_SND_SOC_ES8323)	+= snd-soc-es8323.o
 
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
diff --git a/sound/soc/codecs/es8323.c b/sound/soc/codecs/es8323.c
new file mode 100644
index 000000000000..3fadfec24d6f
--- /dev/null
+++ b/sound/soc/codecs/es8323.c
@@ -0,0 +1,982 @@
+/*
+ * es8323.c -- es8323 ALSA SoC audio driver
+ *
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on es8323.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of.h>
+
+#ifdef CONFIG_HHBF_FAST_REBOOT
+#include <linux/reboot.h>
+#endif
+
+#include "es8323.h"
+
+#define AUDIO_NAME "ES8323"
+#define ES8323_VERSION "v1.0"
+
+#ifndef es8323_DEF_VOL
+#define es8323_DEF_VOL 0x1c
+#endif
+
+static int id;
+
+/* codec private data */
+struct es8323_priv {
+	struct snd_soc_codec *codec;
+	int (*set_bias_level)(struct snd_soc_codec *,
+			       enum snd_soc_bias_level level);
+	enum snd_soc_control_type control_type;
+	unsigned int sysclk;
+};
+
+/*
+ * Debug
+ */
+
+#define ES8323_DEBUG 1
+
+#ifdef ES8323_DEBUG
+#define alsa_dbg(format, arg...) \
+	pr_info("== ES8323 == " format, ## arg)
+#else
+#define alsa_dbg(format, arg...) do {} while (0)
+#endif
+
+/*
+ * es8323 register cache
+ * We can't read the es8323 register space when we
+ * are using 2 wire for device control, so we cache them instead.
+ */
+static const u16 es8323_reg[] = {
+	0x06, 0x1C, 0xC3, 0xFC, /* 0 */
+	0xC0, 0x00, 0x00, 0x7C,	/* 4 */
+	0x80, 0x00, 0x00, 0x06,	/* 8 */
+	0x00, 0x06, 0x30, 0x30,	/* 12 */
+	0xC0, 0xC0, 0x38, 0xB0,	/* 16 */
+	0x32, 0x06, 0x00, 0x00,	/* 20 */
+	0x06, 0x32, 0xC0, 0xC0,	/* 24 */
+	0x08, 0x06, 0x1F, 0xF7,	/* 28 */
+	0xFD, 0xFF, 0x1F, 0xF7,	/* 32 */
+	0xFD, 0xFF, 0x00, 0x38,	/* 36 */
+	0x38, 0x38, 0x38, 0x38,	/* 40 */
+	0x38, 0x00, 0x00, 0x00,	/* 44 */
+	0x00, 0x00, 0x00, 0x00,	/* 48 */
+	0x00, 0x00, 0x00, 0x00,	/* 52 */
+};
+
+static const u16 es8323_probe_regs[] = {
+	/* same as 8323 probe reg order */
+	ES8323_DACCONTROL23,
+	ES8323_MASTERMODE,
+	ES8323_DACCONTROL21,
+	ES8323_CONTROL1,
+	ES8323_CONTROL2,
+
+	ES8323_CHIPLOPOW1,
+	ES8323_CHIPLOPOW2,
+	ES8323_DACPOWER,
+	ES8323_ADCPOWER,
+	ES8323_ANAVOLMANAG,
+
+	ES8323_ADCCONTROL1,
+	ES8323_ADCCONTROL2,
+	ES8323_ADCCONTROL3,
+	ES8323_ADCCONTROL4,
+	ES8323_ADCCONTROL5,
+
+	ES8323_LADC_VOL,
+	ES8323_RADC_VOL,
+
+	ES8323_ADCCONTROL10,
+	ES8323_ADCCONTROL11,
+	ES8323_ADCCONTROL12,
+	ES8323_ADCCONTROL13,
+	ES8323_ADCCONTROL14,
+
+	ES8323_DACCONTROL1,
+	ES8323_DACCONTROL2,
+	ES8323_LDAC_VOL,
+	ES8323_RDAC_VOL,
+	ES8323_DAC_MUTE,
+
+	ES8323_DACCONTROL17,
+	ES8323_DACCONTROL20,
+	ES8323_CHIPPOWER,
+
+	ES8323_LOUT1_VOL,
+	ES8323_ROUT1_VOL,
+	ES8323_LOUT2_VOL,
+	ES8323_ROUT2_VOL,
+};
+
+static const struct snd_kcontrol_new es8323_snd_controls[] = {
+SOC_DOUBLE_R("Capture Volume", ES8323_LADC_VOL, ES8323_RADC_VOL, 0, 192, 1),
+};
+
+/*
+ * DAPM Controls
+ */
+
+/* Channel Input Mixer */
+static const char * const es8323_line_texts[] = {
+	"Line 1", "Line 2", "Differential"
+};
+
+static const unsigned int es8323_line_values[] = {
+	0, 1, 3
+};
+
+static const struct soc_enum es8323_lline_enum =
+SOC_VALUE_ENUM_SINGLE(ES8323_ADCCONTROL3, 6, 0xC0,
+		      ARRAY_SIZE(es8323_line_texts), es8323_line_texts,
+		      es8323_line_values);
+static const struct snd_kcontrol_new es8323_left_line_controls =
+SOC_DAPM_VALUE_ENUM("Route", es8323_lline_enum);
+
+static const struct soc_enum es8323_rline_enum =
+SOC_VALUE_ENUM_SINGLE(ES8323_ADCCONTROL3, 4, 0x30,
+		      ARRAY_SIZE(es8323_line_texts), es8323_line_texts,
+		      es8323_line_values);
+static const struct snd_kcontrol_new es8323_right_line_controls =
+SOC_DAPM_VALUE_ENUM("Route", es8323_lline_enum);
+
+/* Left Mixer */
+static const struct snd_kcontrol_new es8323_left_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Left Playback Switch", ES8323_DACCONTROL17, 7, 1, 0),
+	SOC_DAPM_SINGLE("Left Bypass Switch", ES8323_DACCONTROL17, 6, 1, 0),
+};
+
+/* Right Mixer */
+static const struct snd_kcontrol_new es8323_right_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Right Playback Switch", ES8323_DACCONTROL20, 7, 1, 0),
+	SOC_DAPM_SINGLE("Right Bypass Switch", ES8323_DACCONTROL20, 6, 1, 0),
+};
+
+/* Differential Mux */
+static const char * const es8323_diff_sel[] = { "Line 1", "Line 2" };
+
+static const struct soc_enum left_diffmux =
+SOC_ENUM_SINGLE(ES8323_ADCCONTROL2, 2, 2, es8323_diff_sel);
+static const struct snd_kcontrol_new es8323_left_diffmux_controls =
+SOC_DAPM_ENUM("Route", left_diffmux);
+
+static const struct soc_enum right_diffmux =
+SOC_ENUM_SINGLE(ES8323_ADCCONTROL3, 7, 2, es8323_diff_sel);
+static const struct snd_kcontrol_new es8323_right_diffmux_controls =
+SOC_DAPM_ENUM("Route", right_diffmux);
+
+/* Mono ADC Mux */
+static const char * const es8323_mono_mux[] = {
+	"Stereo", "Mono (Left)", "Mono (Right)", "NONE"
+};
+
+static const struct soc_enum monomux =
+SOC_ENUM_SINGLE(ES8323_ADCCONTROL3, 3, 4, es8323_mono_mux);
+static const struct snd_kcontrol_new es8323_monomux_controls =
+SOC_DAPM_ENUM("Route", monomux);
+
+static const struct snd_soc_dapm_widget es8323_dapm_widgets[] = {
+	/* DAC Part */
+	SND_SOC_DAPM_MIXER("Left Mixer", SND_SOC_NOPM, 0, 0,
+			   &es8323_left_mixer_controls[0],
+			   ARRAY_SIZE(es8323_left_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Mixer", SND_SOC_NOPM, 0, 0,
+			   &es8323_right_mixer_controls[0],
+			   ARRAY_SIZE(es8323_right_mixer_controls)),
+
+	SND_SOC_DAPM_MUX("Left Line Mux", SND_SOC_NOPM, 0, 0,
+			 &es8323_left_line_controls),
+	SND_SOC_DAPM_MUX("Right Line Mux", SND_SOC_NOPM, 0, 0,
+			 &es8323_right_line_controls),
+
+	SND_SOC_DAPM_DAC("Left DAC", "Left Playback", ES8323_DACCONTROL38, 7,
+			 1),
+	SND_SOC_DAPM_DAC("Right DAC", "Right Playback", ES8323_DACCONTROL38, 6,
+			 1),
+	SND_SOC_DAPM_PGA("Left Out 1", SND_SOC_NOPM, 5, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Out 1", SND_SOC_NOPM, 4, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left Out 2", SND_SOC_NOPM, 3, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Out 2", SND_SOC_NOPM, 2, 0, NULL, 0),
+
+	SND_SOC_DAPM_OUTPUT("LOUT1"),
+	SND_SOC_DAPM_OUTPUT("ROUT1"),
+	SND_SOC_DAPM_OUTPUT("LOUT2"),
+	SND_SOC_DAPM_OUTPUT("ROUT2"),
+	SND_SOC_DAPM_OUTPUT("VREF"),
+
+	/* -------------------------------------------- */
+	/* ADC Part */
+	/* -------------------------------------------- */
+	SND_SOC_DAPM_MUX("Differential Left Mux", SND_SOC_NOPM, 0, 0,
+			 &es8323_left_diffmux_controls),
+	SND_SOC_DAPM_MUX("Differential Right Mux", SND_SOC_NOPM, 0, 0,
+			 &es8323_right_diffmux_controls),
+
+	SND_SOC_DAPM_MUX("Left ADC Mux", SND_SOC_NOPM, 0, 0,
+			 &es8323_monomux_controls),
+	SND_SOC_DAPM_MUX("Right ADC Mux", SND_SOC_NOPM, 0, 0,
+			 &es8323_monomux_controls),
+
+	SND_SOC_DAPM_PGA("Left Analog Input", 0x37 /*ES8323_ADCPOWER */ , 7, 1,
+			 NULL, 0),
+	SND_SOC_DAPM_PGA("Right Analog Input", 0x37 /*ES8323_ADCPOWER */ , 6, 1,
+			 NULL, 0),
+	SND_SOC_DAPM_ADC("Left ADC", "Left Capture", 0x37 /*ES8323_ADCPOWER */ ,
+			 5, 1),
+	SND_SOC_DAPM_ADC("Right ADC", "Right Capture",
+			 0x37 /*ES8323_ADCPOWER */ , 4, 1),
+
+	SND_SOC_DAPM_MICBIAS("Mic Bias", 0x37 /*ES8323_ADCPOWER */ , 3, 1),
+
+	SND_SOC_DAPM_INPUT("MICIN"),
+	SND_SOC_DAPM_INPUT("LINPUT1"),
+	SND_SOC_DAPM_INPUT("LINPUT2"),
+	SND_SOC_DAPM_INPUT("RINPUT1"),
+	SND_SOC_DAPM_INPUT("RINPUT2"),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	/* left mixer */
+	{"Left Mixer", "Left Playback Switch", "Left DAC"},
+
+	/* right mixer */
+	{"Right Mixer", "Right Playback Switch", "Right DAC"},
+
+	/* left out 1 */
+	{"Left Out 1", NULL, "Left Mixer"},
+	{"LOUT1", NULL, "Left Out 1"},
+
+	/* right out 1 */
+	{"Right Out 1", NULL, "Right Mixer"},
+	{"ROUT1", NULL, "Right Out 1"},
+
+	/* left out 2 */
+	{"Left Out 2", NULL, "Left Mixer"},
+	{"LOUT2", NULL, "Left Out 2"},
+
+	/* right out 2 */
+	{"Right Out 2", NULL, "Right Mixer"},
+	{"ROUT2", NULL, "Right Out 2"},
+
+	/* Differential Mux */
+	{"Differential Left Mux", "Line 1", "LINPUT1"},
+	{"Differential Right Mux", "Line 1", "RINPUT1"},
+	{"Differential Left Mux", "Line 2", "LINPUT2"},
+	{"Differential Right Mux", "Line 2", "RINPUT2"},
+
+	/* Left Line Mux */
+	{"Left Line Mux", "Line 1", "LINPUT1"},
+	{"Left Line Mux", "Line 2", "LINPUT2"},
+	{"Left Line Mux", "Differential", "Differential Left Mux"},
+
+	/* Right Line Mux */
+	{"Right Line Mux", "Line 1", "RINPUT1"},
+	{"Right Line Mux", "Line 2", "RINPUT2"},
+	{"Right Line Mux", "Differential", "Differential Right Mux"},
+
+	/* Left ADC Mux */
+	{"Left ADC Mux", "Stereo", "Left Line Mux"},
+/* {"Left ADC Mux", "Mono (Left)" , "Left Line Mux"}, */
+
+	/* Right ADC Mux */
+	{"Right ADC Mux", "Stereo", "Right Line Mux"},
+/* {"Right ADC Mux", "Mono (Right)", "Right Line Mux"}, */
+
+	/* ADC */
+	{"Left ADC", NULL, "Left ADC Mux"},
+	{"Right ADC", NULL, "Right ADC Mux"},
+
+	{"Left ADC", NULL, "Mic Bias"},
+	{"Right ADC", NULL, "Mic Bias"},
+
+	{"Mic Bias", NULL, "MICIN"},
+};
+
+struct _coeff_div {
+	u32 mclk;
+	u32 rate;
+	u16 fs;
+	u8 sr:5;
+	u8 single_double:1;
+	u8 blckdiv:4;
+};
+
+/* codec hifi mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+	/* 8k */
+	{12000000, 8000, 1500, 0x1B, 0, 0xa},
+
+	/* 11.025k */
+	{12000000, 11025, 1088, 0x19, 0, 0xa},
+
+	/* 12k */
+	{12000000, 12000, 1000, 0x18, 0, 0xa},
+
+	/* 16k */
+	{12000000, 16000, 750, 0x17, 0, 0x6},
+
+	/* 22.05k */
+	{12000000, 22050, 544, 0x16, 0, 0x6},
+
+	/* 24k */
+	{12000000, 24000, 500, 0x15, 0, 0x6},
+
+	/* 32k */
+	{12000000, 32000, 375, 0x14, 0, 0x6},
+
+	/* 44.1k */
+	{11289600, 44100, 256, 0x02, 0, 0x4},
+	{12000000, 44100, 272, 0x13, 0, 0x4},
+
+	/* 48k */
+	{12000000, 48000, 250, 0x12, 0, 0x4},
+	{12288000, 48000, 256, 0x02, 0, 0x4},
+
+	/* 88.2k */
+	{12000000, 88200, 136, 0x11, 1, 0x2},
+
+	/* 96k */
+	{12000000, 96000, 125, 0x10, 1, 0x2},
+};
+
+static int es8323_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
+				 int div_id, int div)
+{
+	return 0;
+}
+
+static unsigned int es8323_read_reg_cache(struct snd_soc_codec *codec,
+					  unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+
+	if (reg >= codec->driver->reg_cache_size)
+		return -1;
+	return cache[reg];
+}
+
+static int es8323_write(struct snd_soc_codec *codec, unsigned int reg,
+			unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	u8 data[2];
+	int ret;
+
+	BUG_ON(codec->volatile_register);
+
+	data[0] = reg;
+	data[1] = value & 0x00ff;
+
+	if (reg < codec->driver->reg_cache_size)
+		cache[reg] = value;
+	ret = codec->hw_write(codec->control_data, data, 2);
+
+	if (ret == 2)
+		return 0;
+	if (ret < 0)
+		return ret;
+	else
+		return -EIO;
+}
+
+static int es8323_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				 int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct es8323_priv *es8323 = snd_soc_codec_get_drvdata(codec);
+	alsa_dbg("%s----%d, %d\n", __func__, __LINE__, freq);
+	switch (freq) {
+	case 11289600:
+	case 12000000:
+	case 12288000:
+	case 16934400:
+	case 18432000:
+		es8323->sysclk = freq;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int es8323_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u8 iface = 0;
+	u8 adciface = 0;
+	u8 daciface = 0;
+	alsa_dbg("%s----%d, fmt[%02x]\n", __func__, __LINE__, fmt);
+
+	iface = snd_soc_read(codec, ES8323_IFACE);
+	adciface = snd_soc_read(codec, ES8323_ADC_IFACE);
+	daciface = snd_soc_read(codec, ES8323_DAC_IFACE);
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:	/* MASTER MODE */
+		iface |= 0x80;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:	/* SLAVE MODE */
+		iface &= 0x7F;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		adciface &= 0xFC;
+		/* daciface &= 0xF9; //updated by david-everest,5-25 */
+		daciface &= 0xF9;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		iface &= 0xDF;
+		adciface &= 0xDF;
+		/* daciface &= 0xDF; //UPDATED BY david-everest,5-25 */
+		daciface &= 0xBF;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x20;
+		/* adciface &= 0xDF; //UPDATED BY david-everest,5-25 */
+		adciface |= 0x20;
+		/* daciface &= 0xDF; //UPDATED BY david-everest,5-25 */
+		daciface |= 0x40;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x20;
+		/* adciface |= 0x40; //UPDATED BY david-everest,5-25 */
+		adciface &= 0xDF;
+		/* daciface |= 0x40; //UPDATED BY david-everest,5-25 */
+		daciface &= 0xBF;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface &= 0xDF;
+		adciface |= 0x20;
+		/* daciface |= 0x20; //UPDATED BY david-everest,5-25 */
+		daciface |= 0x40;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	snd_soc_update_bits(codec, ES8323_IFACE, iface, iface);
+	snd_soc_update_bits(codec, ES8323_ADC_IFACE, adciface, adciface);
+	snd_soc_update_bits(codec, ES8323_DAC_IFACE, daciface, daciface);
+	return 0;
+}
+
+static int es8323_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+
+	u16 iface;
+
+	alsa_dbg("es8323_pcm_hw_params()----%d, sampling rate[%d]\n", __LINE__,
+		 params_rate(params));
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		alsa_dbg("es8323_pcm_hw_params() playback stream\n\n");
+
+		iface = snd_soc_read(codec, ES8323_DAC_IFACE) & 0xC7;
+
+		/* bit size */
+		switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			iface |= 0x0018;
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			iface |= 0x0008;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			iface |= 0x0020;
+			break;
+		}
+		/* snd_soc_write(codec, ES8323_DAC_IFACE, iface); */
+		snd_soc_update_bits(codec, ES8323_DAC_IFACE, iface, iface);
+	} else {
+		alsa_dbg("es8323_pcm_hw_params() capture stream\n\n");
+
+		iface = snd_soc_read(codec, ES8323_ADC_IFACE) & 0xE3;
+
+		/* bit size */
+		switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			iface |= 0x000C;
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			iface |= 0x0004;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			iface |= 0x0010;
+			break;
+		}
+		/* set iface */
+		/* snd_soc_write(codec, ES8323_ADC_IFACE, iface); */
+		snd_soc_update_bits(codec, ES8323_ADC_IFACE, iface, iface);
+	}
+
+	return 0;
+}
+
+static int es8323_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	unsigned char val = 0;
+
+	alsa_dbg("%s----%d, %d\n", __func__, __LINE__, mute);
+
+	val = snd_soc_read(codec, ES8323_DAC_MUTE);
+	if (mute)
+		snd_soc_write(codec, 0x19, 0x26);
+	else
+		snd_soc_write(codec, 0x19, 0x22);
+
+	return 0;
+}
+
+static int es8323_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		snd_soc_write(codec, ES8323_DACPOWER, 0x3C);
+		dev_dbg(codec->dev, "%s on\n", __func__);
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		dev_dbg(codec->dev, "%s prepare\n", __func__);
+		snd_soc_write(codec, ES8323_ANAVOLMANAG, 0x7C);
+		snd_soc_write(codec, ES8323_CHIPLOPOW1, 0x00);
+		snd_soc_write(codec, ES8323_CHIPLOPOW2, 0x00);
+		snd_soc_write(codec, ES8323_CHIPPOWER, 0x00);
+		snd_soc_write(codec, ES8323_ADCPOWER, 0x00);
+		snd_soc_write(codec, ES8323_DACPOWER, 0x3C);
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		dev_dbg(codec->dev, "%s standby\n", __func__);
+		/* es8323_off_amp(true); */
+		snd_soc_write(codec, ES8323_CHIPLOPOW1, 0xFF);
+		snd_soc_write(codec, ES8323_CHIPLOPOW2, 0xFF);
+		break;
+	case SND_SOC_BIAS_OFF:
+		dev_dbg(codec->dev, "%s off\n", __func__);
+		/* es8323_off_amp(true); */
+		snd_soc_write(codec, ES8323_ADCPOWER, 0xFC);
+		/* snd_soc_write(codec, ES8323_DACPOWER, 0xC0); */
+		snd_soc_write(codec, ES8323_CHIPLOPOW1, 0xFF);
+		snd_soc_write(codec, ES8323_CHIPLOPOW2, 0xFF);
+		snd_soc_write(codec, ES8323_CHIPPOWER, 0xFF);
+		snd_soc_write(codec, ES8323_ANAVOLMANAG, 0x7B);
+		break;
+	}
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+#define ES8323_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
+	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+#define ES8323_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_ops es8323_ops = {
+	.hw_params = es8323_pcm_hw_params,
+	.set_fmt = es8323_set_dai_fmt,
+	.set_sysclk = es8323_set_dai_sysclk,
+	.digital_mute = es8323_mute,
+	.set_clkdiv = es8323_set_dai_clkdiv,
+};
+
+struct snd_soc_dai_driver es8323_dai = {
+	.name = "es8323-hifi",
+	.playback = {
+	     .stream_name = "Playback",
+	     .channels_min = 1,
+	     .channels_max = 2,
+	     .rates = ES8323_RATES,
+	     .formats = ES8323_FORMATS,
+	},
+	.capture = {
+	    .stream_name = "Capture",
+	    .channels_min = 1,
+	    .channels_max = 2,
+	    .rates = ES8323_RATES,
+	    .formats = ES8323_FORMATS,
+	},
+	.ops = &es8323_ops,
+};
+
+#ifdef CONFIG_PM
+static int es8323_i2c_ts_suspend(struct device *dev)
+{
+	struct i2c_client *client = i2c_verify_client(dev);
+	struct es8323_priv *es8323 = dev_get_drvdata(&client->dev);
+	struct snd_soc_codec *codec = es8323->codec;
+
+	/* Power off */
+	dev_info(codec->dev, "es8323_i2c_ts_suspend\n");
+	snd_soc_write(codec, 0x19, 0x26);
+	snd_soc_write(codec, 0x30, 0x18);
+	snd_soc_write(codec, 0x31, 0x18);
+	msleep(20);
+	snd_soc_write(codec, 0x30, 0x08);
+	snd_soc_write(codec, 0x31, 0x08);
+	snd_soc_write(codec, ES8323_CONTROL2, 0x58);
+	snd_soc_write(codec, ES8323_CONTROL1, 0x32);
+	snd_soc_write(codec, ES8323_CHIPPOWER, 0xf3);
+	snd_soc_write(codec, ES8323_DACPOWER, 0xc0);
+	snd_soc_write(codec, ES8323_DACCONTROL26, 0x00);
+	snd_soc_write(codec, ES8323_DACCONTROL27, 0x00);
+	snd_soc_write(codec, ES8323_CONTROL1, 0x30);
+	snd_soc_write(codec, ES8323_CONTROL1, 0x34);
+	msleep(20);
+	return 0;
+}
+
+static int es8323_i2c_ts_resume(struct device *dev)
+{
+	struct i2c_client *client = i2c_verify_client(dev);
+	struct es8323_priv *es8323 = dev_get_drvdata(&client->dev);
+	struct snd_soc_codec *codec = es8323->codec;
+
+	dev_info(codec->dev, "es8323_i2c_ts_resume\n");
+
+	snd_soc_write(codec, 0x02, 0xf3);
+	snd_soc_write(codec, 0x2B, 0x80);
+	snd_soc_write(codec, 0x08, 0x00);
+	snd_soc_write(codec, 0x00, 0x32);
+	snd_soc_write(codec, 0x01, 0x72);
+	snd_soc_write(codec, 0x03, 0x59);
+	snd_soc_write(codec, 0x05, 0x00);
+	snd_soc_write(codec, 0x06, 0x00);
+	snd_soc_write(codec, 0x09, 0x99);
+	snd_soc_write(codec, 0x0a, 0xf0);
+	snd_soc_write(codec, 0x0b, 0x82);
+	snd_soc_write(codec, 0x0C, 0x4c);
+	snd_soc_write(codec, 0x0d, 0x02);
+	snd_soc_write(codec, 0x10, 0x00);
+	snd_soc_write(codec, 0x11, 0x00);
+	snd_soc_write(codec, 0x12, 0xea);
+	snd_soc_write(codec, 0x13, 0xa0);
+	snd_soc_write(codec, 0x14, 0x05);
+	snd_soc_write(codec, 0x15, 0x06);
+	snd_soc_write(codec, 0x16, 0x33);
+	snd_soc_write(codec, 0x17, 0x18);
+	snd_soc_write(codec, 0x18, 0x02);
+	snd_soc_write(codec, 0x1A, 0x00);
+	snd_soc_write(codec, 0x1B, 0x00);
+
+	snd_soc_write(codec, 0x26, 0x12);
+	snd_soc_write(codec, 0x27, 0xb8);
+	snd_soc_write(codec, 0x2A, 0xb8);
+	snd_soc_write(codec, 0x02, 0x00);
+	snd_soc_write(codec, 0x19, 0x22);
+	snd_soc_write(codec, 0x04, 0x00);
+	/* msleep(100); */
+	snd_soc_write(codec, 0x2e, 0x08);
+	snd_soc_write(codec, 0x2f, 0x08);
+	snd_soc_write(codec, 0x30, 0x08);
+	snd_soc_write(codec, 0x31, 0x08);
+	/* msleep(200); */
+	snd_soc_write(codec, 0x2e, 0x0f);
+	snd_soc_write(codec, 0x2f, 0x0f);
+	snd_soc_write(codec, 0x30, 0x0f);
+	snd_soc_write(codec, 0x31, 0x0f);
+	/* msleep(200); */
+	snd_soc_write(codec, 0x2e, 0x1e);
+	snd_soc_write(codec, 0x2f, 0x1e);
+	snd_soc_write(codec, 0x30, 0x1e);
+	snd_soc_write(codec, 0x31, 0x1e);
+	snd_soc_write(codec, 0x04, 0x3c);
+
+	/* Sync reg_cache with the hardware */
+#if 0
+	for (i = 0; i < ARRAY_SIZE(/*es8323_reg */ es8323_probe_regs); i++) {
+		data[0] = es8323_probe_regs[i];
+		data[1] = cache[es8323_probe_regs[i]] & 0xFF;
+		codec->hw_write(codec->control_data, data, 2);
+	}
+#endif
+	return 0;
+}
+
+static const struct dev_pm_ops es8323_dev_pm_ops = {
+	.suspend = es8323_i2c_ts_suspend,
+	.resume = es8323_i2c_ts_resume,
+};
+
+#else
+#define es8323_i2c_ts_suspend NULL
+#define es8323_i2c_ts_resume NULL
+#endif
+
+static void es8323_shutdown(struct i2c_client *client)
+{
+	struct es8323_priv *es8323 = dev_get_drvdata(&client->dev);
+	struct snd_soc_codec *codec = es8323->codec;
+
+	snd_soc_write(codec, ES8323_CONTROL2, 0x58);
+	snd_soc_write(codec, ES8323_CONTROL1, 0x32);
+	snd_soc_write(codec, ES8323_CHIPPOWER, 0xf3);
+	snd_soc_write(codec, ES8323_DACPOWER, 0xc0);
+	snd_soc_write(codec, ES8323_DACCONTROL26, 0x00);
+	snd_soc_write(codec, ES8323_DACCONTROL27, 0x00);
+	snd_soc_write(codec, ES8323_CONTROL1, 0x30);
+	snd_soc_write(codec, ES8323_CONTROL1, 0x34);
+	/* return 0; */
+}
+
+static int es8323_probe(struct snd_soc_codec *codec)
+{
+	struct es8323_priv *es8323 = snd_soc_codec_get_drvdata(codec);
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	int ret = 0, idread = 0;
+
+	es8323->set_bias_level = es8323_set_bias_level;
+	es8323->codec = codec;
+	codec->read = es8323_read_reg_cache;
+	codec->write = es8323_write;
+	codec->hw_write = (hw_write_t) i2c_master_send;
+	codec->control_data = container_of(codec->dev, struct i2c_client, dev);
+	idread = snd_soc_read(codec, ES8323_DACCONTROL18);
+	if (idread == 0x28) {
+		id = 0;
+		dev_info(codec->dev, "es8323_probe\r\n");
+	} else if (idread == 0x00) {
+		id = 1;
+		dev_info(codec->dev, "es8323s_probe\r\n");
+	} else {
+		id = 0;
+		dev_info(codec->dev, "id read invalid, id=%d\n", idread);
+	}
+	es8323_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	if (ret) {
+		dev_err(codec->dev, "ES8323 chip not exist\n");
+		kfree(es8323);
+	}
+	if (id == 0) {
+		snd_soc_write(codec, 0x02, 0xf3);
+		snd_soc_write(codec, 0x2B, 0x80);
+		snd_soc_write(codec, 0x08, 0x00);
+		snd_soc_write(codec, 0x00, 0x32);
+		snd_soc_write(codec, 0x01, 0x72);
+		snd_soc_write(codec, 0x03, 0x59);
+		snd_soc_write(codec, 0x05, 0x00);
+		snd_soc_write(codec, 0x06, 0x00);
+		snd_soc_write(codec, 0x09, 0x99);
+		snd_soc_write(codec, 0x0a, 0xf0);
+		snd_soc_write(codec, 0x0b, 0x82);
+		snd_soc_write(codec, 0x0C, 0x4c);
+		snd_soc_write(codec, 0x0d, 0x02);
+		snd_soc_write(codec, 0x10, 0x00);
+		snd_soc_write(codec, 0x11, 0x00);
+		snd_soc_write(codec, 0x12, 0xea);
+		snd_soc_write(codec, 0x13, 0x70);
+		snd_soc_write(codec, 0x14, 0x05);
+		snd_soc_write(codec, 0x15, 0x06);
+		snd_soc_write(codec, 0x16, 0x33);
+		snd_soc_write(codec, 0x17, 0x18);
+		snd_soc_write(codec, 0x18, 0x02);
+		snd_soc_write(codec, 0x1A, 0x00);
+		snd_soc_write(codec, 0x1B, 0x00);
+		snd_soc_write(codec, 0x26, 0x12);
+		snd_soc_write(codec, 0x27, 0xb8);
+		snd_soc_write(codec, 0x2A, 0xb8);
+		snd_soc_write(codec, 0x02, 0x00);
+		snd_soc_write(codec, 0x19, 0x02);
+		snd_soc_write(codec, 0x04, 0x2c);
+		msleep(100);
+		snd_soc_write(codec, 0x2e, 0x00);
+		snd_soc_write(codec, 0x2f, 0x00);
+		snd_soc_write(codec, 0x30, 0x08);
+		snd_soc_write(codec, 0x31, 0x08);
+		msleep(200);
+		snd_soc_write(codec, 0x30, 0x0f);
+		snd_soc_write(codec, 0x31, 0x0f);
+		msleep(200);
+		snd_soc_write(codec, 0x30, 0x1e);
+		snd_soc_write(codec, 0x31, 0x1e);
+
+	} else if (id == 1) {
+		snd_soc_write(codec, 0x35, 0xa0);
+		snd_soc_write(codec, 0x38, 0x02);
+		snd_soc_write(codec, 0x02, 0xf3);
+		snd_soc_write(codec, 0x00, 0x36);
+		snd_soc_write(codec, 0x01, 0x72);
+		snd_soc_write(codec, 0x08, 0x00);
+		snd_soc_write(codec, 0x2d, 0x10);
+		snd_soc_write(codec, 0x2b, 0x80);
+		snd_soc_write(codec, 0x06, 0xff);
+		snd_soc_write(codec, 0x05, 0x00);
+		snd_soc_write(codec, 0x07, 0x7c);
+		snd_soc_write(codec, 0x0a, 0xf0);
+		snd_soc_write(codec, 0x0b, 0x82);
+		snd_soc_write(codec, 0x09, 0x50);
+		snd_soc_write(codec, 0x0C, 0x4c);
+		snd_soc_write(codec, 0x0d, 0x02);
+		snd_soc_write(codec, 0x0e, 0x2c);
+		snd_soc_write(codec, 0x10, 0x00);
+		snd_soc_write(codec, 0x11, 0x00);
+		snd_soc_write(codec, 0x12, 0xd2);
+		snd_soc_write(codec, 0x13, 0x80);
+		snd_soc_write(codec, 0x14, 0x05);
+		snd_soc_write(codec, 0x15, 0x06);
+		snd_soc_write(codec, 0x16, 0x33);
+		snd_soc_write(codec, 0x17, 0x18);
+		snd_soc_write(codec, 0x18, 0x02);
+		snd_soc_write(codec, 0x1A, 0x00);
+		snd_soc_write(codec, 0x1B, 0x00);
+		snd_soc_write(codec, 0x26, 0x12);
+		snd_soc_write(codec, 0x27, 0x80);
+		snd_soc_write(codec, 0x2A, 0x80);
+		snd_soc_write(codec, 0x03, 0x00);
+		snd_soc_write(codec, 0x02, 0x00);
+		snd_soc_write(codec, 0x19, 0x20);
+		snd_soc_write(codec, 0x04, 0x2c);
+		msleep(100);
+		snd_soc_write(codec, 0x2e, 0x00);
+		snd_soc_write(codec, 0x2f, 0x00);
+		snd_soc_write(codec, 0x30, 0x08);
+		snd_soc_write(codec, 0x31, 0x08);
+		msleep(200);
+		snd_soc_write(codec, 0x30, 0x0f);
+		snd_soc_write(codec, 0x31, 0x0f);
+		msleep(200);
+		snd_soc_write(codec, 0x30, 0x1e);
+		snd_soc_write(codec, 0x31, 0x1e);
+		snd_soc_write(codec, 0x32, 0x03);
+	}
+	es8323_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	snd_soc_add_codec_controls(codec, es8323_snd_controls,
+				   ARRAY_SIZE(es8323_snd_controls));
+	snd_soc_dapm_new_controls(dapm, es8323_dapm_widgets,
+				  ARRAY_SIZE(es8323_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));
+	pr_info("es8323 init ok, drv version = %s\n", ES8323_VERSION);
+	return ret;
+}
+
+/* power down chip */
+static int es8323_remove(struct snd_soc_codec *codec)
+{
+	es8323_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_es8323 = {
+	.probe = es8323_probe,
+	.remove = es8323_remove,
+	.set_bias_level = es8323_set_bias_level,
+	.reg_cache_size = ARRAY_SIZE(es8323_reg),
+	.reg_word_size = sizeof(u16),
+	.reg_cache_default = es8323_reg,
+	.read = es8323_read_reg_cache,
+	.write = es8323_write,
+};
+
+static int es8323_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct es8323_priv *es8323;
+	int ret;
+
+	es8323 = kzalloc(sizeof(struct es8323_priv), GFP_KERNEL);
+	if (es8323 == NULL)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, es8323);
+	es8323->control_type = SND_SOC_I2C;
+
+	ret = snd_soc_register_codec(&i2c->dev,
+				     &soc_codec_dev_es8323, &es8323_dai, 1);
+	if (ret < 0)
+		kfree(es8323);
+	return ret;
+}
+
+static int es8323_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	kfree(i2c_get_clientdata(client));
+	return 0;
+}
+
+static const struct of_device_id es8323_of_match[] = {
+	{.compatible = "es, es8323",},
+	{},
+};
+
+static const struct i2c_device_id es8323_i2c_id[] = {
+	{"es8323", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, es8323_i2c_id);
+
+static struct i2c_driver es8323_i2c_driver = {
+	.driver = {
+		   .name = "es8323",
+		   .owner = THIS_MODULE,
+		   .of_match_table = es8323_of_match,
+#ifdef CONFIG_PM
+		   .pm = &es8323_dev_pm_ops,
+#endif
+		   },
+	.probe = es8323_i2c_probe,
+	.remove = es8323_i2c_remove,
+	.shutdown = es8323_shutdown,
+	.id_table = es8323_i2c_id,
+};
+module_i2c_driver(es8323_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC es8323 driver");
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/codecs/es8323.h b/sound/soc/codecs/es8323.h
new file mode 100644
index 000000000000..bdea3c98f08b
--- /dev/null
+++ b/sound/soc/codecs/es8323.h
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on ES8323.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ES8323_H
+#define _ES8323_H
+
+#define CONFIG_HHTECH_MINIPMP	1
+
+/* ES8323 register space */
+
+#define ES8323_CONTROL1         0x00
+#define ES8323_CONTROL2         0x01
+#define ES8323_CHIPPOWER        0x02
+#define ES8323_ADCPOWER         0x03
+#define ES8323_DACPOWER         0x04
+#define ES8323_CHIPLOPOW1       0x05
+#define ES8323_CHIPLOPOW2       0x06
+#define ES8323_ANAVOLMANAG      0x07
+#define ES8323_MASTERMODE       0x08
+#define ES8323_ADCCONTROL1      0x09
+#define ES8323_ADCCONTROL2      0x0a
+#define ES8323_ADCCONTROL3      0x0b
+#define ES8323_ADCCONTROL4      0x0c
+#define ES8323_ADCCONTROL5      0x0d
+#define ES8323_ADCCONTROL6      0x0e
+#define ES8323_ADCCONTROL7      0x0f
+#define ES8323_ADCCONTROL8      0x10
+#define ES8323_ADCCONTROL9      0x11
+#define ES8323_ADCCONTROL10     0x12
+#define ES8323_ADCCONTROL11     0x13
+#define ES8323_ADCCONTROL12     0x14
+#define ES8323_ADCCONTROL13     0x15
+#define ES8323_ADCCONTROL14     0x16
+
+#define ES8323_DACCONTROL1      0x17
+#define ES8323_DACCONTROL2      0x18
+#define ES8323_DACCONTROL3      0x19
+#define ES8323_DACCONTROL4      0x1a
+#define ES8323_DACCONTROL5      0x1b
+#define ES8323_DACCONTROL6      0x1c
+#define ES8323_DACCONTROL7      0x1d
+#define ES8323_DACCONTROL8      0x1e
+#define ES8323_DACCONTROL9      0x1f
+#define ES8323_DACCONTROL10     0x20
+#define ES8323_DACCONTROL11     0x21
+#define ES8323_DACCONTROL12     0x22
+#define ES8323_DACCONTROL13     0x23
+#define ES8323_DACCONTROL14     0x24
+#define ES8323_DACCONTROL15     0x25
+#define ES8323_DACCONTROL16     0x26
+#define ES8323_DACCONTROL17     0x27
+#define ES8323_DACCONTROL18     0x28
+#define ES8323_DACCONTROL19     0x29
+#define ES8323_DACCONTROL20     0x2a
+#define ES8323_DACCONTROL21     0x2b
+#define ES8323_DACCONTROL22     0x2c
+#define ES8323_DACCONTROL23     0x2d
+#define ES8323_DACCONTROL24     0x2e
+#define ES8323_DACCONTROL25     0x2f
+#define ES8323_DACCONTROL26     0x30
+#define ES8323_DACCONTROL27     0x31
+#define ES8323_DACCONTROL28     0x32
+#define ES8323_DACCONTROL29     0x33
+#define ES8323_DACCONTROL30     0x34
+#define ES8323_DACCONTROL38     0x66
+
+#define ES8323_LADC_VOL         ES8323_ADCCONTROL8
+#define ES8323_RADC_VOL         ES8323_ADCCONTROL9
+
+#define ES8323_LDAC_VOL         ES8323_DACCONTROL4
+#define ES8323_RDAC_VOL         ES8323_DACCONTROL5
+
+#define ES8323_LOUT1_VOL        ES8323_DACCONTROL24
+#define ES8323_ROUT1_VOL        ES8323_DACCONTROL25
+#define ES8323_LOUT2_VOL        ES8323_DACCONTROL26
+#define ES8323_ROUT2_VOL        ES8323_DACCONTROL27
+
+#define ES8323_ADC_MUTE         ES8323_ADCCONTROL7
+#define ES8323_DAC_MUTE         ES8323_DACCONTROL3
+
+#define ES8323_IFACE            ES8323_MASTERMODE
+
+#define ES8323_ADC_IFACE        ES8323_ADCCONTROL4
+#define ES8323_ADC_SRATE        ES8323_ADCCONTROL5
+
+#define ES8323_DAC_IFACE        ES8323_DACCONTROL1
+#define ES8323_DAC_SRATE        ES8323_DACCONTROL2
+
+#define ES8323_CACHEREGNUM      53
+#define ES8323_SYSCLK	        0
+
+struct es8323_setup_data {
+	int i2c_bus;
+	unsigned short i2c_address;
+};
+
+extern struct snd_soc_dai_driver es8323_dai;
+
+#if 1				/* lzcx */
+#define ES8323_PLL1			0
+#define ES8323_PLL2			1
+
+/* clock inputs */
+#define ES8323_MCLK		0
+#define ES8323_PCMCLK		1
+
+/* clock divider id's */
+#define ES8323_PCMDIV		0
+#define ES8323_BCLKDIV		1
+#define ES8323_VXCLKDIV		2
+
+/* PCM clock dividers */
+#define ES8323_PCM_DIV_1	(0 << 6)
+#define ES8323_PCM_DIV_3	(2 << 6)
+#define ES8323_PCM_DIV_5_5	(3 << 6)
+#define ES8323_PCM_DIV_2	(4 << 6)
+#define ES8323_PCM_DIV_4	(5 << 6)
+#define ES8323_PCM_DIV_6	(6 << 6)
+#define ES8323_PCM_DIV_8	(7 << 6)
+
+/* BCLK clock dividers */
+#define ES8323_BCLK_DIV_1	(0 << 7)
+#define ES8323_BCLK_DIV_2	(1 << 7)
+#define ES8323_BCLK_DIV_4	(2 << 7)
+#define ES8323_BCLK_DIV_8	(3 << 7)
+
+/* VXCLK clock dividers */
+#define ES8323_VXCLK_DIV_1	(0 << 6)
+#define ES8323_VXCLK_DIV_2	(1 << 6)
+#define ES8323_VXCLK_DIV_4	(2 << 6)
+#define ES8323_VXCLK_DIV_8	(3 << 6)
+#define ES8323_VXCLK_DIV_16	(4 << 6)
+
+#define ES8323_DAI_HIFI		0
+#define ES8323_DAI_VOICE		1
+
+#define ES8323_1536FS 1536
+#define ES8323_1024FS	1024
+#define ES8323_768FS	768
+#define ES8323_512FS	512
+#define ES8323_384FS	384
+#define ES8323_256FS	256
+#define ES8323_128FS	128
+#endif
+
+#endif
-- 
2.11.0


From 3192bb20a1a625f40795eb489d8fe367e003f120 Mon Sep 17 00:00:00 2001
From: kszaq <kszaquitto@gmail.com>
Date: Wed, 1 Mar 2017 22:13:44 +0100
Subject: [PATCH 03/11] sound/soc: limit available sample rates for codecs used
 in Amlogic devices and extend them to allow full range of HDMI output
 playback

---
 sound/soc/aml/m8/aml_spdif_codec.c |  5 ++---
 sound/soc/codecs/aml_codec_t9015.c |  6 ++----
 sound/soc/codecs/dummy_codec.c     |  5 ++---
 sound/soc/codecs/es8323.c          | 11 ++++-------
 4 files changed, 10 insertions(+), 17 deletions(-)

diff --git a/sound/soc/aml/m8/aml_spdif_codec.c b/sound/soc/aml/m8/aml_spdif_codec.c
index 92b0e636533c..0a2b4724fe75 100644
--- a/sound/soc/aml/m8/aml_spdif_codec.c
+++ b/sound/soc/aml/m8/aml_spdif_codec.c
@@ -26,9 +26,8 @@
 
 #define DRV_NAME "spdif-dit"
 
-#define STUB_RATES	(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)
-#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
-	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+#define STUB_RATES	SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000
+#define STUB_FORMATS	SNDRV_PCM_FMTBIT_S16_LE
 
 struct pinctrl *pin_spdif_ctl;
 struct device *spdif_dev;
diff --git a/sound/soc/codecs/aml_codec_t9015.c b/sound/soc/codecs/aml_codec_t9015.c
index 490f5c2d3f3f..146a3afa50cd 100644
--- a/sound/soc/codecs/aml_codec_t9015.c
+++ b/sound/soc/codecs/aml_codec_t9015.c
@@ -428,10 +428,8 @@ static int aml_T9015_audio_resume(struct snd_soc_codec *codec)
 	return 0;
 }
 
-#define T9015_AUDIO_STEREO_RATES SNDRV_PCM_RATE_8000_96000
-#define T9015_AUDIO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE \
-			| SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE \
-			| SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S32_LE)
+#define T9015_AUDIO_STEREO_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)
+#define T9015_AUDIO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
 struct snd_soc_dai_ops T9015_audio_aif_dai_ops = {
 	.hw_params = aml_T9015_hw_params,
diff --git a/sound/soc/codecs/dummy_codec.c b/sound/soc/codecs/dummy_codec.c
index 0696213f7074..f933384cc5f7 100644
--- a/sound/soc/codecs/dummy_codec.c
+++ b/sound/soc/codecs/dummy_codec.c
@@ -16,9 +16,8 @@ struct dummy_codec_private {
 	struct snd_soc_codec codec;
 };
 
-#define DUMMY_CODEC_RATES		(SNDRV_PCM_RATE_8000_192000)
-#define DUMMY_CODEC_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
-		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+#define DUMMY_CODEC_RATES		(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)
+#define DUMMY_CODEC_FORMATS		SNDRV_PCM_FMTBIT_S32_LE
 
 static int dummy_codec_pcm_hw_params(struct snd_pcm_substream *substream,
 				     struct snd_pcm_hw_params *params,
diff --git a/sound/soc/codecs/es8323.c b/sound/soc/codecs/es8323.c
index 3fadfec24d6f..80d361df250d 100644
--- a/sound/soc/codecs/es8323.c
+++ b/sound/soc/codecs/es8323.c
@@ -619,12 +619,9 @@ static int es8323_set_bias_level(struct snd_soc_codec *codec,
 	return 0;
 }
 
-#define ES8323_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
-	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \
-	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+#define ES8323_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)
 
-#define ES8323_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
-	SNDRV_PCM_FMTBIT_S24_LE)
+#define ES8323_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
 static struct snd_soc_dai_ops es8323_ops = {
 	.hw_params = es8323_pcm_hw_params,
@@ -638,8 +635,8 @@ struct snd_soc_dai_driver es8323_dai = {
 	.name = "es8323-hifi",
 	.playback = {
 	     .stream_name = "Playback",
-	     .channels_min = 1,
-	     .channels_max = 2,
+	     .channels_min = 2,
+	     .channels_max = 8,
 	     .rates = ES8323_RATES,
 	     .formats = ES8323_FORMATS,
 	},
-- 
2.11.0


From bba75e4892db8ef195b671b1ea2701078b0b1ea4 Mon Sep 17 00:00:00 2001
From: kszaq <kszaquitto@gmail.com>
Date: Tue, 7 Mar 2017 20:09:37 +0100
Subject: [PATCH 04/11] sound/soc: partially revert 8ab0f59

---
 sound/soc/aml/m8/aml_spdif_codec.c | 5 +++--
 sound/soc/codecs/dummy_codec.c     | 5 +++--
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/sound/soc/aml/m8/aml_spdif_codec.c b/sound/soc/aml/m8/aml_spdif_codec.c
index 0a2b4724fe75..ac76ef6dfb7f 100644
--- a/sound/soc/aml/m8/aml_spdif_codec.c
+++ b/sound/soc/aml/m8/aml_spdif_codec.c
@@ -26,8 +26,9 @@
 
 #define DRV_NAME "spdif-dit"
 
-#define STUB_RATES	SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000
-#define STUB_FORMATS	SNDRV_PCM_FMTBIT_S16_LE
+#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
 struct pinctrl *pin_spdif_ctl;
 struct device *spdif_dev;
diff --git a/sound/soc/codecs/dummy_codec.c b/sound/soc/codecs/dummy_codec.c
index f933384cc5f7..0696213f7074 100644
--- a/sound/soc/codecs/dummy_codec.c
+++ b/sound/soc/codecs/dummy_codec.c
@@ -16,8 +16,9 @@ struct dummy_codec_private {
 	struct snd_soc_codec codec;
 };
 
-#define DUMMY_CODEC_RATES		(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)
-#define DUMMY_CODEC_FORMATS		SNDRV_PCM_FMTBIT_S32_LE
+#define DUMMY_CODEC_RATES		(SNDRV_PCM_RATE_8000_192000)
+#define DUMMY_CODEC_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
+		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
 static int dummy_codec_pcm_hw_params(struct snd_pcm_substream *substream,
 				     struct snd_pcm_hw_params *params,
-- 
2.11.0


From 04f5c3d8ff627d9f705b3b65ac13da43251d4581 Mon Sep 17 00:00:00 2001
From: kszaq <kszaquitto@gmail.com>
Date: Wed, 5 Apr 2017 22:37:32 +0200
Subject: [PATCH 05/11] sound/soc/codecs/es8323: disable debug logging

---
 sound/soc/codecs/es8323.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sound/soc/codecs/es8323.c b/sound/soc/codecs/es8323.c
index 80d361df250d..c08816f0d071 100644
--- a/sound/soc/codecs/es8323.c
+++ b/sound/soc/codecs/es8323.c
@@ -59,7 +59,7 @@ struct es8323_priv {
  * Debug
  */
 
-#define ES8323_DEBUG 1
+// #define ES8323_DEBUG 1
 
 #ifdef ES8323_DEBUG
 #define alsa_dbg(format, arg...) \
-- 
2.11.0


From 695f2f00c6f90f596c70a65bfb86078a9f11368c Mon Sep 17 00:00:00 2001
From: kszaq <kszaquitto@gmail.com>
Date: Wed, 5 Apr 2017 22:51:35 +0200
Subject: [PATCH 06/11] sound/soc/codecs/es8323: mute on init

---
 sound/soc/codecs/es8323.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sound/soc/codecs/es8323.c b/sound/soc/codecs/es8323.c
index c08816f0d071..9d3f541d0b9a 100644
--- a/sound/soc/codecs/es8323.c
+++ b/sound/soc/codecs/es8323.c
@@ -827,7 +827,7 @@ static int es8323_probe(struct snd_soc_codec *codec)
 		snd_soc_write(codec, 0x27, 0xb8);
 		snd_soc_write(codec, 0x2A, 0xb8);
 		snd_soc_write(codec, 0x02, 0x00);
-		snd_soc_write(codec, 0x19, 0x02);
+		snd_soc_write(codec, 0x19, 0x26);
 		snd_soc_write(codec, 0x04, 0x2c);
 		msleep(100);
 		snd_soc_write(codec, 0x2e, 0x00);
-- 
2.11.0


From 6341300916629684e4c769ca7bdf5c50dafc4177 Mon Sep 17 00:00:00 2001
From: kszaq <kszaquitto@gmail.com>
Date: Sun, 9 Apr 2017 00:55:58 +0200
Subject: [PATCH 07/11] sound/soc/aml/m8/aml_audio_hw: clean up a bit

---
 sound/soc/aml/m8/aml_audio_hw.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/sound/soc/aml/m8/aml_audio_hw.c b/sound/soc/aml/m8/aml_audio_hw.c
index 5c21fd527e13..e9d28de06ca6 100644
--- a/sound/soc/aml/m8/aml_audio_hw.c
+++ b/sound/soc/aml/m8/aml_audio_hw.c
@@ -981,8 +981,6 @@ void audio_out_i2s_enable(unsigned flag)
 		/* Maybe cause POP noise */
 		/* audio_i2s_unmute(); */
 	} else {
-		aml_write_cbus(AIU_RST_SOFT, 0x01);
-		aml_read_cbus(AIU_I2S_SYNC);
 		aml_cbus_update_bits(AIU_MEM_I2S_CONTROL, 0x3 << 1, 0);
 
 		/* Maybe cause POP noise */
-- 
2.11.0


From eabb2b522e411511ed4eb8a5d3796ce22bce4950 Mon Sep 17 00:00:00 2001
From: kszaq <kszaquitto@gmail.com>
Date: Tue, 11 Apr 2017 01:18:57 +0200
Subject: [PATCH 08/11] sound/soc/aml: revert buffer_bytes_max for i2s

---
 sound/soc/aml/m8/aml_i2s.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sound/soc/aml/m8/aml_i2s.c b/sound/soc/aml/m8/aml_i2s.c
index b7ff908c8b4d..426a8e941794 100644
--- a/sound/soc/aml/m8/aml_i2s.c
+++ b/sound/soc/aml/m8/aml_i2s.c
@@ -94,7 +94,7 @@ static const struct snd_pcm_hardware aml_i2s_hardware = {
 	.period_bytes_max = 32 * 1024,
 	.periods_min = 4,
 	.periods_max = 64,
-	.buffer_bytes_max = 32 * 1024 * 64,
+	.buffer_bytes_max = 128 * 1024 * 2 * 2,
 
 	.rate_min = 8000,
 	.rate_max = 192000,
-- 
2.11.0


From b824e9b38ce1f439ae08369af0a41459cfd5fae1 Mon Sep 17 00:00:00 2001
From: kszaq <kszaquitto@gmail.com>
Date: Tue, 11 Apr 2017 01:21:49 +0200
Subject: [PATCH 09/11] sound/soc/codecs: revert sample rates and format
 changes

---
 sound/soc/codecs/aml_codec_t9015.c | 6 ++++--
 sound/soc/codecs/es8323.c          | 7 +++++--
 2 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/sound/soc/codecs/aml_codec_t9015.c b/sound/soc/codecs/aml_codec_t9015.c
index 146a3afa50cd..490f5c2d3f3f 100644
--- a/sound/soc/codecs/aml_codec_t9015.c
+++ b/sound/soc/codecs/aml_codec_t9015.c
@@ -428,8 +428,10 @@ static int aml_T9015_audio_resume(struct snd_soc_codec *codec)
 	return 0;
 }
 
-#define T9015_AUDIO_STEREO_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)
-#define T9015_AUDIO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)
+#define T9015_AUDIO_STEREO_RATES SNDRV_PCM_RATE_8000_96000
+#define T9015_AUDIO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE \
+			| SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE \
+			| SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S32_LE)
 
 struct snd_soc_dai_ops T9015_audio_aif_dai_ops = {
 	.hw_params = aml_T9015_hw_params,
diff --git a/sound/soc/codecs/es8323.c b/sound/soc/codecs/es8323.c
index 9d3f541d0b9a..3e7bd6f06c13 100644
--- a/sound/soc/codecs/es8323.c
+++ b/sound/soc/codecs/es8323.c
@@ -619,9 +619,12 @@ static int es8323_set_bias_level(struct snd_soc_codec *codec,
 	return 0;
 }
 
-#define ES8323_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)
+#define ES8323_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
+	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
 
-#define ES8323_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)
+#define ES8323_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
 
 static struct snd_soc_dai_ops es8323_ops = {
 	.hw_params = es8323_pcm_hw_params,
-- 
2.11.0


From 721dbfffbba3a166774d5d2b58f54405d8ab52bb Mon Sep 17 00:00:00 2001
From: kszaq <kszaquitto@gmail.com>
Date: Fri, 14 Apr 2017 19:14:21 +0200
Subject: [PATCH 10/11] sound/soc/aml/m8: fix Dolby Atmos by signalling MAT_MLP
 for HDMI. Requires setting parameter from userspace.

---
 sound/soc/aml/m8/aml_spdif_dai.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/sound/soc/aml/m8/aml_spdif_dai.c b/sound/soc/aml/m8/aml_spdif_dai.c
index 63ca0274eecc..da7f7b78b2c0 100644
--- a/sound/soc/aml/m8/aml_spdif_dai.c
+++ b/sound/soc/aml/m8/aml_spdif_dai.c
@@ -234,7 +234,7 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 	/* audio_set_spdif_clk_div(); */
 	/* 958 divisor: 0=no div; 1=div by 2; 2=div by 3; 3=div by 4. */
 	if (runtime->rate == 192000 && runtime->channels == 8 && runtime->format == SNDRV_PCM_FORMAT_S16) {
-		IEC958_mode_codec = 8; /* TrueHD/DTS-HD MA */
+		// IEC958_mode_codec = 8; /* TrueHD/DTS-HD MA */
 		pr_info("set 4x audio clk for 958\n");
 		aml_cbus_update_bits(AIU_CLK_CTRL, 3 << 4, 0 << 4);
 	} else if (runtime->rate == 192000 && runtime->channels == 2 && runtime->format == SNDRV_PCM_FORMAT_S16) {
@@ -314,8 +314,11 @@ void aml_hw_iec958_init(struct snd_pcm_substream *substream, int samesrc)
 
 	/* notify hdmi to set audio type */
 	if (IEC958_mode_codec == 8) {
-		/* TrueHD/DTS-HD MA */
+		/* DTS-HD MA */
 		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD_MA, substream);
+	} else if (IEC958_mode_codec == 7) {
+		/* TrueHD */
+		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_MAT_MLP, substream);
 	} else if (iec958_mode == AIU_958_MODE_PCM_RAW) {
 		/* AC3/DTS/EAC3 */
 		aout_notifier_call_chain(AOUT_EVENT_RAWDATA_DTS_HD, substream);
-- 
2.11.0


From 354f1017efb073569eb8cbb9b5bbeebccad02040 Mon Sep 17 00:00:00 2001
From: kszaq <kszaquitto@gmail.com>
Date: Fri, 14 Apr 2017 19:14:59 +0200
Subject: [PATCH 11/11] sound/soc/codecs: make 176.4kHz and 192kHz available
 for devices with analog output

---
 sound/soc/codecs/aml_codec_t9015.c | 2 +-
 sound/soc/codecs/es8323.c          | 3 ++-
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/sound/soc/codecs/aml_codec_t9015.c b/sound/soc/codecs/aml_codec_t9015.c
index 490f5c2d3f3f..100fcee1c7e0 100644
--- a/sound/soc/codecs/aml_codec_t9015.c
+++ b/sound/soc/codecs/aml_codec_t9015.c
@@ -428,7 +428,7 @@ static int aml_T9015_audio_resume(struct snd_soc_codec *codec)
 	return 0;
 }
 
-#define T9015_AUDIO_STEREO_RATES SNDRV_PCM_RATE_8000_96000
+#define T9015_AUDIO_STEREO_RATES SNDRV_PCM_RATE_8000_192000
 #define T9015_AUDIO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE \
 			| SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE \
 			| SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S32_LE)
diff --git a/sound/soc/codecs/es8323.c b/sound/soc/codecs/es8323.c
index 3e7bd6f06c13..9e0382b680c6 100644
--- a/sound/soc/codecs/es8323.c
+++ b/sound/soc/codecs/es8323.c
@@ -621,7 +621,8 @@ static int es8323_set_bias_level(struct snd_soc_codec *codec,
 
 #define ES8323_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
 	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \
-	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | \
+	SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)
 
 #define ES8323_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
 	SNDRV_PCM_FMTBIT_S24_LE)
-- 
2.11.0

