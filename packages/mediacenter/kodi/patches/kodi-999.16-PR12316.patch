From f44ee991657b6c15c5e0c1a386468e58e182003e Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Tue, 20 Jun 2017 20:42:05 +0200
Subject: [PATCH 1/2] [windowing/AML] - added display 3d mode switching via
 amhdmitx0/config sysfs interface

---
 xbmc/utils/AMLUtils.cpp                     | 55 +++++++++++++++++++++++++++--
 xbmc/utils/AMLUtils.h                       |  3 +-
 xbmc/windowing/amlogic/WinSystemAmlogic.cpp |  2 +-
 3 files changed, 56 insertions(+), 4 deletions(-)

diff --git a/xbmc/utils/AMLUtils.cpp b/xbmc/utils/AMLUtils.cpp
index c674655c9782..6ec77eca9a5a 100644
--- a/xbmc/utils/AMLUtils.cpp
+++ b/xbmc/utils/AMLUtils.cpp
@@ -33,6 +33,7 @@
 #include "guilib/gui3d.h"
 #include "utils/RegExp.h"
 #include "filesystem/SpecialProtocol.h"
+#include "rendering/RenderSystem.h"
 
 #include "linux/fb.h"
 #include <sys/ioctl.h>
@@ -58,7 +59,8 @@ bool aml_hw3d_present()
   static int has_hw3d = -1;
   if (has_hw3d == -1)
   {
-    if (SysfsUtils::Has("/sys/class/ppmgr/ppmgr_3d_mode"))
+    if (SysfsUtils::Has("/sys/class/ppmgr/ppmgr_3d_mode") ||
+        SysfsUtils::Has("/sys/class/amhdmitx/amhdmitx0/config"))
       has_hw3d = 1;
     else
       has_hw3d = 0;
@@ -145,6 +147,10 @@ bool aml_permissions()
     {
       CLog::Log(LOGERROR, "AML: no rw on /sys/class/ppmgr/ppmgr_3d_mode");
     }
+    if (!SysfsUtils::HasRW("/sys/class/amhdmitx/amhdmitx0/config"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/amhdmitx/amhdmitx0/config");
+    }
     if (!SysfsUtils::HasRW("/sys/class/vfm/map"))
     {
       CLog::Log(LOGERROR, "AML: no rw on /sys/class/vfm/map");
@@ -588,7 +594,7 @@ bool aml_get_native_resolution(RESOLUTION_INFO *res)
   return aml_mode_to_resolution(mode.c_str(), res);
 }
 
-bool aml_set_native_resolution(const RESOLUTION_INFO &res, std::string framebuffer_name)
+bool aml_set_native_resolution(const RESOLUTION_INFO &res, std::string framebuffer_name, const int stereo_mode)
 {
   bool result = false;
 
@@ -599,6 +605,7 @@ bool aml_set_native_resolution(const RESOLUTION_INFO &res, std::string framebuff
     result = aml_set_display_resolution(res.strId.c_str(), framebuffer_name);
 
   aml_handle_scale(res);
+  aml_handle_display_stereo_mode(stereo_mode);
 
   return result;
 }
@@ -683,6 +690,50 @@ void aml_handle_scale(const RESOLUTION_INFO &res)
     aml_disable_freeScale();
 }
 
+void aml_handle_display_stereo_mode(const int stereo_mode)
+{
+  static std::string lastHdmiTxConfig = "3doff";
+  
+  std::string command = "3doff";
+  switch (stereo_mode)
+  {
+    case RENDER_STEREO_MODE_SPLIT_VERTICAL:
+      command = "3dlr";
+      break;
+    case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
+      command = "3dtb";
+      break;
+    default:
+      // nothing - command is already initialised to "3doff"
+      break;
+  }
+  
+  CLog::Log(LOGDEBUG, "AMLUtils::aml_handle_display_stereo_mode old mode %s new mode %s", lastHdmiTxConfig.c_str(), command.c_str());
+  // there is no way to read back current mode from sysfs
+  // so we track state internal. Because even
+  // when setting the same mode again - kernel driver
+  // will initiate a new hdmi handshake which is not
+  // what we want of course.
+  // for 3d mode we are called 2 times and need to allow both calls
+  // to succeed. Because the first call doesn't switch mode (i guessi its
+  // timing issue between switching the refreshrate and switching to 3d mode
+  // which needs to occure in the correct order, else switching refresh rate
+  // might reset 3dmode).
+  // So we set the 3d mode - if the last command is different from the current
+  // command - or in case they are the same - we ensure that its not the 3doff
+  // command that gets repeated here.
+  if (lastHdmiTxConfig != command || command != "3doff")
+  {
+    CLog::Log(LOGDEBUG, "AMLUtils::aml_handle_display_stereo_mode setting new mode");
+    lastHdmiTxConfig = command;
+    SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/config", command);
+  }
+  else
+  {
+    CLog::Log(LOGDEBUG, "AMLUtils::aml_handle_display_stereo_mode - no change needed");
+  }
+}
+
 void aml_enable_freeScale(const RESOLUTION_INFO &res)
 {
   char fsaxis_str[256] = {0};
diff --git a/xbmc/utils/AMLUtils.h b/xbmc/utils/AMLUtils.h
index 5323ae9ac448..aa695d3bac15 100644
--- a/xbmc/utils/AMLUtils.h
+++ b/xbmc/utils/AMLUtils.h
@@ -64,12 +64,13 @@ void aml_set_audio_passthrough(bool passthrough);
 bool aml_IsHdmiConnected();
 bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res);
 bool aml_get_native_resolution(RESOLUTION_INFO *res);
-bool aml_set_native_resolution(const RESOLUTION_INFO &res, std::string framebuffer_name);
+bool aml_set_native_resolution(const RESOLUTION_INFO &res, std::string framebuffer_name, const int stereo_mode);
 bool aml_probe_resolutions(std::vector<RESOLUTION_INFO> &resolutions);
 bool aml_get_preferred_resolution(RESOLUTION_INFO *res);
 bool aml_set_display_resolution(const char *resolution, std::string framebuffer_name);
 void aml_setup_video_scaling(const char *mode);
 void aml_handle_scale(const RESOLUTION_INFO &res);
+void aml_handle_display_stereo_mode(const int stereo_mode);
 void aml_enable_freeScale(const RESOLUTION_INFO &res);
 void aml_disable_freeScale();
 void aml_set_framebuffer_resolution(const RESOLUTION_INFO &res, std::string framebuffer_name);
diff --git a/xbmc/windowing/amlogic/WinSystemAmlogic.cpp b/xbmc/windowing/amlogic/WinSystemAmlogic.cpp
index 588566751fe6..dd2e756df00d 100644
--- a/xbmc/windowing/amlogic/WinSystemAmlogic.cpp
+++ b/xbmc/windowing/amlogic/WinSystemAmlogic.cpp
@@ -134,7 +134,7 @@ bool CWinSystemAmlogic::CreateNewWindow(const std::string& name,
   nativeWindow->height = res.iHeight;
   m_nativeWindow = static_cast<EGLNativeWindowType>(nativeWindow);
 
-  aml_set_native_resolution(res, m_framebuffer_name);
+  aml_set_native_resolution(res, m_framebuffer_name, stereo_mode);
 
   if (!m_delayDispReset)
   {

From c15a9028b129e99fe772749efd76ec43de67b5ec Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Tue, 20 Jun 2017 20:42:26 +0200
Subject: [PATCH 2/2] [AMLCodec]: - added software fallback for rendering 3d to
 2d if ppmgr_3d is not available

---
 .../cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp | 52 +++++++++++++++++++---
 xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.h  |  2 +-
 2 files changed, 46 insertions(+), 8 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp
index ff6c0d2af80a..98ffd4230877 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp
@@ -2053,10 +2053,20 @@ void CAMLCodec::SetVideoSaturation(const int saturation)
   SysfsUtils::SetInt("/sys/class/video/saturation", saturation);
 }
 
-void CAMLCodec::SetVideo3dMode(const int mode3d)
+bool CAMLCodec::SetVideo3dMode(const int mode3d)
 {
-  CLog::Log(LOGDEBUG, "CAMLCodec::SetVideo3dMode:mode3d(0x%x)", mode3d);
-  SysfsUtils::SetInt("/sys/class/ppmgr/ppmgr_3d_mode", mode3d);
+  bool result = true;
+  if (SysfsUtils::Has("/sys/class/ppmgr/ppmgr_3d_mode"))
+  {
+    CLog::Log(LOGDEBUG, "CAMLCodec::SetVideo3dMode:mode3d(0x%x)", mode3d);
+    SysfsUtils::SetInt("/sys/class/ppmgr/ppmgr_3d_mode", mode3d);
+  }
+  else
+  {
+    CLog::Log(LOGINFO, "CAMLCodec::SetVideo3dMode: ppmgr_3d support not found in kernel.");
+    result = false;
+  }
+  return result;
 }
 
 std::string CAMLCodec::GetStereoMode()
@@ -2190,13 +2200,41 @@ void CAMLCodec::SetVideoRect(const CRect &SrcRect, const CRect &DestRect)
   {
     std::string mode = GetStereoMode();
     if (mode == "left_right")
-      SetVideo3dMode(MODE_3D_TO_2D_L);
+    {
+      if (!SetVideo3dMode(MODE_3D_TO_2D_L))
+      {
+        // fall back to software scaling if no hw support
+        // was found
+        dst_rect.x2 *= 2.0;
+      }
+    }
     else if (mode == "right_left")
-      SetVideo3dMode(MODE_3D_TO_2D_R);
+    {
+      if (!SetVideo3dMode(MODE_3D_TO_2D_R))
+      {
+        // fall back to software scaling if no hw support
+        // was found
+        dst_rect.x2 *= 2.0;
+      }
+    }
     else if (mode == "top_bottom")
-      SetVideo3dMode(MODE_3D_TO_2D_T);
+    {
+      if (!SetVideo3dMode(MODE_3D_TO_2D_T))
+      {
+        // fall back to software scaling if no hw support
+        // was found
+        dst_rect.y2 *= 2.0;
+      }
+    }
     else if (mode == "bottom_top")
-      SetVideo3dMode(MODE_3D_TO_2D_B);
+    {
+      if (!SetVideo3dMode(MODE_3D_TO_2D_B))
+      {
+        // fall back to software scaling if no hw support
+        // was found
+        dst_rect.y2 *= 2.0;
+      }
+    }
     else
       SetVideo3dMode(MODE_3D_DISABLE);
   }
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.h
index cdcb1e6024ab..a3aae836db15 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.h
@@ -70,7 +70,7 @@ class CAMLCodec
   void          SetVideoContrast(const int contrast);
   void          SetVideoBrightness(const int brightness);
   void          SetVideoSaturation(const int saturation);
-  void          SetVideo3dMode(const int mode3d);
+  bool          SetVideo3dMode(const int mode3d);
   std::string   GetStereoMode();
   bool          OpenAmlVideo(const CDVDStreamInfo &hints);
   void          CloseAmlVideo();
